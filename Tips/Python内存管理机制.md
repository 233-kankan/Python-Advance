####  Python内存管理机制

##### 引用计数
Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数
-  引用计数 +
	- 一个对象分配到一个新名称
	- 将其中一个放入一个容器中 (如列表、元祖或字典)
-  引用计数 - 
	- 使用del等语句对对象别名进行销毁
	- 引用超出作用域范围或被重新赋值
- 如何查看引用计数
```pyhton
import sys

a = 123
print(sys.getrefcount(a))
# 结果 21
```
sys.getrefcount( )函数可以获得对象的当前引用计数
多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存

#### 垃圾回收(GC)
- 当一个对象的引用计数归零时，它将被GC处理掉
- 标记清除机制
	- 标记清除用来解决循环引用产生的问题，循环引用只有在容器对象才会产生，比如字典，元祖，列表等。首先为了追踪对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个链表，指针分别指向前后两个容器对象，这样可以将对象的循环引用摘除，就可以得出两个对象的有效计数
- 分代回收
	- 了解分类回收，首先要了解一下，GC的阈值，所谓阈值就是一个临界点的值。
随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，创建==释放数量应该是这样子。但是如果存在循环引用的话，肯定是创建>释放数量，当创建数与释放数量的差值达到规定的阈值的时候，当当当当~分代回收机制就登场啦。
分代回收思想将对象分为三代（generation 0,1,2）
	- 查看分代回收阀值
```python 
import gc

print(gc.get_threshold())
# 打印结果：(700, 10, 10)

# 可以设置分代阀值，如下
# gc.set_threshold(700, 10, 5)
```